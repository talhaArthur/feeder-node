(()=>{"use strict";const e=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:32768,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;if(e<=0)throw"bufferLength must be >= 1";if(t<1)throw"nChannels must >= 1";this._data=new Float32Array(e*t),this._nChannels=t,this._readPos=0,this._writePos=0}get bufferLength(){return this._data.length/this._nChannels}getNReadableSamples(){if(this._readPos==this._writePos)return 0;let e;return e=this._readPos<this._writePos?this._writePos-this._readPos:this._data.length-this._readPos+this._writePos,e/this._nChannels}read(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,s=null===t?Array.apply(null,Array(this._nChannels)).map((()=>new Float32Array(e))):t,i=Math.min(e,this.getNReadableSamples()),a=this._readPos;for(let e=0;e<i;e++)for(let t=0;t<s.length;t++)a===this._data.length&&(a=0),s[t][e]=this._data[a++];return this._readPos=a,s}_resize(e){let t=this.getNReadableSamples()*this._nChannels,s=new Float32Array(e+t),i=this._readPos;for(let e=0;e<t;e++)s[e]=this._data[i++];this._writePos=t,this._readPos=0,this._data=s}write(e){if(!ArrayBuffer.isView(e))throw`Must submit a TypedArray. Received ${e.constructor.name}`;let t=!1;e.length>this._data.length&&(this._resize(e.length),t=!0);let s=this._writePos;for(let t=0;t<e.length;t++)s===this._data.length&&(s=0),this._data[s++]=e[t];return this._writePos=s,[t,this._data.length/this._nChannels]}clear(){this._readPos=0,this._writePos=0}},t=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:32768,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;if(e<=0)throw"initialCapacity must be >= 1";if(t<1)throw"nChannels must >= 1";this._queue=[],this._nChannels=t,this._initialCapacity=e,this._samplesInQueue=0}get bufferLength(){return this._samplesInQueue}getNReadableSamples(){return this._samplesInQueue}read(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,s=Math.min(e,this.getNReadableSamples());if(0===s)return null===t?Array.apply(null,Array(this._nChannels)).map((()=>new Float32Array(0))):t.map((t=>t.fill(0,0,e)));let i=null===t?Array.apply(null,Array(this._nChannels)).map((()=>new Float32Array(e))):t;if(null!==t)for(let e=0;e<i.length;e++)i[e].fill(0);let a=0;for(;a<s&&this._queue.length>0;){const e=this._queue[0],t=e.length/this._nChannels,h=Math.min(t,s-a);for(let t=0;t<h;t++)for(let s=0;s<this._nChannels;s++)i[s][a+t]=e[t*this._nChannels+s];h===t?this._queue.shift():this._queue[0]=e.slice(h*this._nChannels),a+=h}return this._samplesInQueue-=a,i}write(e){if(!ArrayBuffer.isView(e))throw`Must submit a TypedArray. Received ${e.constructor.name}`;const t=new Float32Array(e);return this._queue.push(t),this._samplesInQueue+=t.length/this._nChannels,[!1,this._samplesInQueue]}clear(){this._queue=[],this._samplesInQueue=0}},s={UNINITIALIZED:1,READY:2,PLAYING:3,STARVED:4};Object.freeze(s);const i={RING_BUFFER:"ring_buffer",FIFO_QUEUE:"fifo_queue"};Object.freeze(i);class a extends AudioWorkletProcessor{constructor(e){super(),this.port.onmessage=this._onMessage.bind(this),this.bufferThreshold,this.nChannels,this.state=s.UNINITIALIZED,this._bufferType=i.RING_BUFFER}process(e,t,i){return this._updateState(),this.state===s.PLAYING?this._buffer.read(128,t[0]):function(e){for(let t=0;t<e.length;t++){let s=e[t];for(let e=0;e<s.length;e++)s[e]=0}}(t[0]),!0}_updateState(){let e=this.state;switch(this.state){case s.UNINITIALIZED:return;case s.PLAYING:0===this._buffer.getNReadableSamples()&&(this.state=s.STARVED);break;case s.READY:case s.STARVED:this._buffer.getNReadableSamples()>=this.bufferThreshold&&(this.state=s.PLAYING)}e!=this.state&&this._notifyStateChange()}_notifyStateChange(){this.port.postMessage({command:"stateChange",state:this.state})}_onMessage(e){let t=e.data,s=t.command;if("init"===s)this._bufferType=t.bufferType,this._init(t.bufferLength,t.nChannels,t.bufferThreshold);else if("feed"===s)this._feed(t.data);else if("setBufferThreshold"===s)this.bufferThreshold=t.threshold;else if("connect"===s)e.ports[0].onmessage=this._onMessage.bind(this);else if("getBufferFill"===s)this._sendBufferFill(t.callbackId);else{if("clearBuffer"!==s)throw Error("command not specified");this._buffer&&this._buffer.clear()}}_sendBufferFill(e){if(!this._buffer)return;const t=this._buffer.getNReadableSamples();this.port.postMessage({command:"bufferFillUpdate",bufferFill:t,callbackId:e})}_feed(e){let[t,s]=this._buffer.write(e);t&&this.port.postMessage({command:"bufferLengthChange",bufferLength:s}),this._sendBufferFill()}_init(a,h,r){this._bufferType===i.FIFO_QUEUE?this._buffer=new t(a,h):this._buffer=new e(a,h),this.bufferThreshold=r,this.state=s.READY,this._notifyStateChange()}}registerProcessor("FeederNode",a)})();